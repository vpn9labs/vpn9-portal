name: Reproducible Build

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      version:
        description: 'Build version'
        required: true
        default: 'dev'

env:
  REGISTRY: ghcr.io

jobs:
  build:
    name: Reproducible Build
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write # For signing
      attestations: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Full history for SOURCE_DATE_EPOCH
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:master
            network=host
      
      - name: Log in to GitHub Container Registry
        # Only login for non-PR events (push, release, workflow_dispatch)
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}
        id: docker_login
      
      - name: Verify login status
        if: github.event_name != 'pull_request'
        run: |
          echo "Login outcome: ${{ steps.docker_login.outcome }}"
          echo "Login conclusion: ${{ steps.docker_login.conclusion }}"
          if [ "${{ steps.docker_login.outcome }}" != "success" ]; then
            echo "::error::Docker login failed!"
            exit 1
          fi
      
      - name: Set build variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
            VERSION="${{ github.ref_name }}"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="pr-${{ github.event.pull_request.number }}"
          fi
          
          COMMIT="${{ github.sha }}"
          SOURCE_DATE_EPOCH="$(git log -1 --format=%ct)"
          BUILD_TIMESTAMP="$(date -u -d "@${SOURCE_DATE_EPOCH}" '+%Y-%m-%dT%H:%M:%SZ')"
          # Use lowercase for the repository name to match GHCR requirements
          IMAGE_NAME="${{ env.REGISTRY }}/$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "commit=${COMMIT}" >> $GITHUB_OUTPUT
          echo "source_date_epoch=${SOURCE_DATE_EPOCH}" >> $GITHUB_OUTPUT
          echo "build_timestamp=${BUILD_TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "Repository: ${{ github.repository }}"
          echo "Image name: ${IMAGE_NAME}"
      
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: false
          tags: |
            vpn9-portal:${{ steps.vars.outputs.version }}
            vpn9-portal:reproducible-${{ steps.vars.outputs.version }}
          build-args: |
            SOURCE_DATE_EPOCH=${{ steps.vars.outputs.source_date_epoch }}
            BUILD_VERSION=${{ steps.vars.outputs.version }}
            BUILD_COMMIT=${{ steps.vars.outputs.commit }}
            BUILD_TIMESTAMP=${{ steps.vars.outputs.build_timestamp }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar
      
      - name: Calculate checksums
        run: |
          sha256sum /tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar > checksums-${{ steps.vars.outputs.version }}.sha256
          sha512sum /tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar > checksums-${{ steps.vars.outputs.version }}.sha512
      
      - name: Load Docker image for SBOM generation
        run: |
          docker load < /tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar
          # Retag images with full registry path
          docker tag vpn9-portal:${{ steps.vars.outputs.version }} ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}
          docker tag vpn9-portal:reproducible-${{ steps.vars.outputs.version }} ${{ steps.vars.outputs.image_name }}:reproducible-${{ steps.vars.outputs.version }}

      # Install cosign for keyless signing and later image signing
      - name: Install cosign (for signing)
        if: github.event_name != 'pull_request'
        uses: sigstore/cosign-installer@v3

      - name: Keylessly sign embedded build-info and embed signature in image
        if: github.event_name != 'pull_request'
        run: |
          set -euo pipefail
          
          # Sign both the main and reproducible images
          for variant in "${{ steps.vars.outputs.version }}" "reproducible-${{ steps.vars.outputs.version }}"; do
            IMAGE="${{ steps.vars.outputs.image_name }}:${variant}"
            echo "Signing image: $IMAGE"
            
            # Extract original CMD before creating container
            ORIGINAL_CMD=$(docker inspect "$IMAGE" --format='{{json .Config.Cmd}}')
            ORIGINAL_ENTRYPOINT=$(docker inspect "$IMAGE" --format='{{json .Config.Entrypoint}}')
            
            CID=$(docker create "$IMAGE" /bin/true)
            trap 'docker rm -f "$CID" >/dev/null 2>&1 || true' EXIT
            docker cp "$CID":/usr/share/vpn9/build-info.json ./build-info.json

            # Sign with Sigstore keyless; emits signature and certificate (only once)
            if [ ! -f build-info.sig ]; then
              cosign sign-blob --yes \
                --output-signature build-info.sig \
                --output-certificate build-info.pem \
                build-info.json
              # Ensure files are world-readable for non-root runtime user inside image
              chmod 0444 build-info.sig build-info.pem
            fi

            # Copy signature, certificate, and cosign verifier into image, then commit with original CMD
            docker cp build-info.sig "$CID":/usr/share/vpn9/build-info.sig
            docker cp build-info.pem "$CID":/usr/share/vpn9/build-info.pem
            docker cp "$(command -v cosign)" "$CID":/usr/local/bin/cosign
            
            # Commit while preserving original CMD and ENTRYPOINT
            docker commit \
              --change "CMD $ORIGINAL_CMD" \
              --change "ENTRYPOINT $ORIGINAL_ENTRYPOINT" \
              "$CID" "$IMAGE" >/dev/null
            docker rm -f "$CID" >/dev/null
            trap - EXIT
          done
      
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}
          artifact-name: sbom-${{ steps.vars.outputs.version }}.spdx
          output-file: sbom-${{ steps.vars.outputs.version }}.spdx
      
      - name: Attest build provenance for artifacts
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            /tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar
            checksums-${{ steps.vars.outputs.version }}.sha256
            checksums-${{ steps.vars.outputs.version }}.sha512
            sbom-${{ steps.vars.outputs.version }}.spdx
      # cosign already installed above
      
      - name: Sign and push image
        # Only push for non-PR events when login succeeded
        # Prevents pushes from forks which won't have write permissions
        if: |
          github.event_name != 'pull_request' && 
          steps.docker_login.conclusion == 'success' &&
          (github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch')
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "Attempting to push to: ${{ steps.vars.outputs.image_name }}"
          # Image should already be loaded from the SBOM generation step
          # Check if image exists, if not load and retag it
          if ! docker image inspect ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }} >/dev/null 2>&1; then
            docker load < /tmp/vpn9-portal-${{ steps.vars.outputs.version }}.tar
            # Retag images with full registry path
            docker tag vpn9-portal:${{ steps.vars.outputs.version }} ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}
            docker tag vpn9-portal:reproducible-${{ steps.vars.outputs.version }} ${{ steps.vars.outputs.image_name }}:reproducible-${{ steps.vars.outputs.version }}
          fi
          
          # Push to GitHub Container Registry
          docker push ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}
          docker push ${{ steps.vars.outputs.image_name }}:reproducible-${{ steps.vars.outputs.version }}
          
          # Sign with cosign if available
          if command -v cosign >/dev/null 2>&1; then
            cosign sign --yes ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}
          fi

      - name: Get image digest
        if: |
          github.event_name != 'pull_request' && 
          steps.docker_login.conclusion == 'success' &&
          (github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch')
        id: image_digest
        run: |
          set -euo pipefail
          DIGEST=$(docker buildx imagetools inspect ${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }} | grep -m1 'Digest:' | awk '{print $2}')
          if [ -z "$DIGEST" ]; then
            echo "::error::Failed to resolve image digest"
            exit 1
          fi
          echo "Resolved digest: $DIGEST"
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"

      - name: Attest container image provenance
        if: |
          github.event_name != 'pull_request' && 
          steps.docker_login.conclusion == 'success' &&
          (github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'workflow_dispatch')
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ${{ steps.vars.outputs.image_name }}
          subject-digest: ${{ steps.image_digest.outputs.digest }}
          push-to-registry: true
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ steps.vars.outputs.version }}
          path: |
            checksums-*.sha256
            checksums-*.sha512
            sbom-*.spdx
      
      - name: Create release (for tags)
        if: github.event_name == 'push' && github.ref_type == 'tag'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            checksums-*.sha256
            checksums-*.sha512
            sbom-*.spdx
          body: |
            ## Reproducible Build Release
            
            This release was built using our reproducible build process.
            
            ### Container Images
            Available on GitHub Container Registry:
            - `${{ steps.vars.outputs.image_name }}:${{ steps.vars.outputs.version }}`
            - `${{ steps.vars.outputs.image_name }}:reproducible-${{ steps.vars.outputs.version }}`
            
            ### Verification
            
            To verify this build is reproducible:
            ```bash
            ./scripts/verify-build.sh ${{ steps.vars.outputs.version }} --rebuild
            ```
            
            ### Build Parameters
            - Version: `${{ steps.vars.outputs.version }}`
            - Commit: `${{ steps.vars.outputs.commit }}`
            - Source Date Epoch: `${{ steps.vars.outputs.source_date_epoch }}`
            - Timestamp: `${{ steps.vars.outputs.build_timestamp }}`
            
            ### Artifacts
            - `checksums-*.sha256` - SHA256 checksums of build artifacts
            - `checksums-*.sha512` - SHA512 checksums of build artifacts
            - `sbom-*.spdx` - Software Bill of Materials
  
  verify:
    name: Verify Reproducibility
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    if: github.event_name == 'pull_request'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Download artifacts
        uses: actions/download-artifact@v5
        with:
          pattern: build-artifacts-*
      
      - name: Rebuild and verify
        run: |
          chmod +x scripts/*.sh
          
          # Get version from previous job
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            VERSION="pr-${{ github.event.pull_request.number }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          
          # Run verification
          ./scripts/verify-build.sh "${VERSION}" --rebuild || true
      
      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reportPath = 'builds/verification/verification-report-pr-${{ github.event.pull_request.number }}.txt';
            
            let comment = '## 🔒 Reproducible Build Verification\n\n';
            
            if (fs.existsSync(reportPath)) {
              const report = fs.readFileSync(reportPath, 'utf8');
              comment += '```\n' + report + '\n```';
            } else {
              comment += '✅ Build completed successfully. Reproducibility verification available after merge.';
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });